<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Custom CSS for the game aesthetics -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #2c3e50;
        }
        canvas {
            background-color: #34495e;
            border: 4px solid #f1c40f;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            touch-action: none; /* Disable default touch actions like scrolling/zooming */
        }
        .btn-game {
            text-shadow: 2px 2px #333;
            transition: all 0.2s ease;
        }
        .btn-game:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }
        .btn-game:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen text-white p-4">

    <!-- Game Container -->
    <div class="flex flex-col items-center space-y-6">
        <h1 class="text-4xl md:text-5xl lg:text-6xl text-center text-[#f1c40f]">SNAKE</h1>

        <!-- Score and Message Display -->
        <div class="flex justify-between items-center w-full max-w-lg px-4">
            <div id="score" class="text-2xl text-green-400">Score: 0</div>
            <div id="message-box" class="text-xl text-red-400 text-center">Press Start to Play!</div>
        </div>

        <!-- Canvas for the game -->
        <canvas id="gameCanvas" width="400" height="400" class="w-full max-w-lg"></canvas>

        <!-- Game Controls -->
        <div class="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4 w-full max-w-lg">
            <button id="startButton" class="btn-game bg-green-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-green-600">Start</button>
            <button id="pauseButton" class="btn-game bg-yellow-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-yellow-600" disabled>Pause</button>
            <button id="resetButton" class="btn-game bg-red-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-red-600">Reset</button>
        </div>
    </div>

    <script>
        // Use a self-invoking function to encapsulate game logic
        (function() {
            // --- GLOBAL GAME VARIABLES AND CONSTANTS ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreDisplay = document.getElementById('score');
            const messageBox = document.getElementById('message-box');
            const startButton = document.getElementById('startButton');
            const pauseButton = document.getElementById('pauseButton');
            const resetButton = document.getElementById('resetButton');

            const GRID_SIZE = 20; // Size of each grid cell
            const CANVAS_SIZE = 400; // Total canvas width/height
            const GAME_SPEED = 100; // Game loop speed in milliseconds
            
            let snake = [];
            let food = {};
            let direction = 'right';
            let score = 0;
            let isGameOver = true;
            let isPaused = false;
            let lastDirection = 'right';
            let touchStartX = 0;
            let touchStartY = 0;
            let gameIntervalId; // Store the interval ID to clear it later

            // --- CORE GAME FUNCTIONS ---

            // Draw everything on the canvas
            function draw() {
                // Clear the canvas for the next frame
                ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

                // Draw the snake
                snake.forEach(segment => {
                    ctx.fillStyle = '#2ecc71';
                    ctx.strokeStyle = '#27ae60';
                    ctx.fillRect(segment.x * GRID_SIZE, segment.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    ctx.strokeRect(segment.x * GRID_SIZE, segment.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                });

                // Draw the food
                ctx.fillStyle = '#e74c3c';
                ctx.strokeStyle = '#c0392b';
                ctx.fillRect(food.x * GRID_SIZE, food.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                ctx.strokeRect(food.x * GRID_SIZE, food.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
            }

            // Update game state logic
            function update() {
                if (isGameOver || isPaused) return;

                // Move the snake by creating a new head
                const head = { x: snake[0].x, y: snake[0].y };
                switch (direction) {
                    case 'up': head.y--; break;
                    case 'down': head.y++; break;
                    case 'left': head.x--; break;
                    case 'right': head.x++; break;
                }

                // Check for collisions with walls
                if (head.x < 0 || head.x >= CANVAS_SIZE / GRID_SIZE || head.y < 0 || head.y >= CANVAS_SIZE / GRID_SIZE) {
                    gameOver();
                    return;
                }

                // Check for self-collision
                for (let i = 1; i < snake.length; i++) {
                    if (head.x === snake[i].x && head.y === snake[i].y) {
                        gameOver();
                        return;
                    }
                }

                // Add the new head to the front of the snake
                snake.unshift(head);
                
                // Check if the snake ate the food
                if (head.x === food.x && head.y === food.y) {
                    score++;
                    scoreDisplay.innerText = `Score: ${score}`;
                    spawnFood();
                } else {
                    // Remove the tail if no food was eaten
                    snake.pop();
                }

                // Update the lastDirection to prevent reversing
                lastDirection = direction;
            }

            // The main game loop
            function gameLoop() {
                update();
                draw();
            }

            // Generate new food at a random position
            function spawnFood() {
                food = {
                    x: Math.floor(Math.random() * (CANVAS_SIZE / GRID_SIZE)),
                    y: Math.floor(Math.random() * (CANVAS_SIZE / GRID_SIZE))
                };
            }

            // Handle game over state
            function gameOver() {
                isGameOver = true;
                clearInterval(gameIntervalId); // Stop the game loop
                messageBox.innerText = `Game Over! Final Score: ${score}`;
                messageBox.classList.add('animate-pulse');
                startButton.disabled = false;
                pauseButton.disabled = true;
            }

            // Reset the game to its initial state
            function resetGame() {
                // Clear any existing game loop
                if (gameIntervalId) {
                    clearInterval(gameIntervalId);
                }
                
                snake = [{ x: 10, y: 10 }];
                direction = 'right';
                lastDirection = 'right';
                score = 0;
                isGameOver = true; // The game is not running after reset
                isPaused = false;
                
                scoreDisplay.innerText = `Score: 0`;
                messageBox.innerText = "Press Start to Play!";
                messageBox.classList.remove('animate-pulse');
                
                // Reset button states
                startButton.disabled = false;
                pauseButton.disabled = true;
                
                draw(); // Draw the initial state
            }

            // --- EVENT HANDLERS ---

            // Handle keyboard input for movement
            function handleKeyPress(e) {
                if (isGameOver || isPaused) return;

                const keyPressed = e.key;
                switch (keyPressed) {
                    case 'ArrowUp':
                        if (lastDirection !== 'down') direction = 'up';
                        break;
                    case 'ArrowDown':
                        if (lastDirection !== 'up') direction = 'down';
                        break;
                    case 'ArrowLeft':
                        if (lastDirection !== 'right') direction = 'left';
                        break;
                    case 'ArrowRight':
                        if (lastDirection !== 'left') direction = 'right';
                        break;
                }
            }

            // Handle touch input for swipe gestures on mobile
            function handleTouchStart(e) {
                if (isGameOver || isPaused) return;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }

            function handleTouchMove(e) {
                if (!touchStartX || !touchStartY || isGameOver || isPaused) {
                    return;
                }
                
                const touchEndX = e.touches[0].clientX;
                const touchEndY = e.touches[0].clientY;
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;

                // Determine the direction of the swipe
                if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal swipe
                    if (dx > 0 && lastDirection !== 'left') direction = 'right';
                    else if (dx < 0 && lastDirection !== 'right') direction = 'left';
                } else {
                    // Vertical swipe
                    if (dy > 0 && lastDirection !== 'up') direction = 'down';
                    else if (dy < 0 && lastDirection !== 'down') direction = 'up';
                }
                
                // Reset touch start points to avoid continuous movement
                touchStartX = null;
                touchStartY = null;
            }

            // Start the game
            function startGame() {
                if (!isGameOver) return; // Prevent multiple starts
                
                // Reset to a clean state before starting
                resetGame(); 

                isGameOver = false;
                messageBox.innerText = "Enjoy!";
                startButton.disabled = true;
                pauseButton.disabled = false;

                spawnFood();
                gameIntervalId = setInterval(gameLoop, GAME_SPEED);
            }

            // Pause/Unpause the game
            function togglePause() {
                if (isGameOver) return;
                isPaused = !isPaused;
                if (isPaused) {
                    pauseButton.innerText = 'Resume';
                    messageBox.innerText = 'Game Paused';
                    messageBox.classList.add('animate-pulse');
                } else {
                    pauseButton.innerText = 'Pause';
                    messageBox.innerText = 'Enjoy!';
                    messageBox.classList.remove('animate-pulse');
                }
            }

            // --- INITIALIZATION AND EVENT LISTENERS ---
            window.onload = function() {
                resetGame(); // Initial setup of the game
                startButton.addEventListener('click', startGame);
                pauseButton.addEventListener('click', togglePause);
                resetButton.addEventListener('click', resetGame);
                document.addEventListener('keydown', handleKeyPress);

                // Add touch listeners for mobile
                canvas.addEventListener('touchstart', handleTouchStart);
                canvas.addEventListener('touchmove', handleTouchMove);
            };
        })();
    </script>
</body>
</html>
